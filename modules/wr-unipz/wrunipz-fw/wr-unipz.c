/********************************************************************************************
 *  wr-unipz.c
 *
 *  created : 2018
 *  author  : Dietrich Beck, GSI-Darmstadt
 *  version : 14-Jan-2019
 *
 *  lm32 program for gateway between UNILAC Pulszentrale and a White Rabbit network
 *  this basically serves a Data Master for UNILAC
 *
 *  source code UNIPZ:
 *  - https://www-acc.gsi.de/viewvc/view/devacc/trunk/eqmodels/pz/common/src/pzus-dpr-def.h (relevant header file)
 *  - https://www-acc.gsi.de/viewvc/view/devacc/trunk/eqmodels/pz/pzu/src/pzu-eqms.c (source code for PZ 1..7)
 * 
 *  'announce' events for the next cycle (received from the SuperPZ) have the following format:
 *  31..24: code (defined in pzus-dpr-def-h, lines 72ff; example: 0x10(use 'Kanal 1'), 0x00(use 'Kanal 0')
 *  23..16: virt acc
 *  15...8: 0
 *   7...1: # of PZ (** counting starts at 1(!) **)
 *  
 * -------------------------------------------------------------------------------------------
 * License Agreement for this software:
 *
 * Copyright (C) 2018  Dietrich Beck
 * GSI Helmholtzzentrum fuer Schwerionenforschung GmbH
 * Planckstrasse 1
 * D-64291 Darmstadt
 * Germany
 *
 * Contact: d.beck@gsi.de
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 3 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *  
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library. If not, see <http://www.gnu.org/licenses/>.
 *
 * For all questions and ideas contact: d.beck@gsi.de
 * Last update: 22-November-2018
 ********************************************************************************************/
#define WRUNIPZ_FW_VERSION 0x000007                                     // make this consistent with makefile

/* standard includes */
#include <stdio.h>
#include <string.h>
#include <inttypes.h>
#include <stdint.h>
#include "mprintf.h"
#include "mini_sdb.h"

/* includes specific for bel_projects */
#include "irq.h"
#include "ebm.h"
#include "aux.h"
#include "dbg.h"
#include "../../../top/gsi_scu/scu_mil.h"                               // register layout of 'MIL macro'
#include "../../../ip_cores/wr-cores/modules/wr_eca/eca_queue_regs.h"   // register layout ECA queue
#include "../../../ip_cores/wr-cores/modules/wr_eca/eca_regs.h"         // register layout ECA control
/*                                                                      
#include "../../../ip_cores/wr-cores/modules/wr_pps_gen/pps_gen_regs.h" // useless register layout, I can't handle this wbgen stuff here
*/
#define WR_PPS_GEN_ESCR         0x1c                                    // External Sync Control Register
#define WR_PPS_GEN_ESCR_MASK    0xC                                     // bit 2: PPS valid, bit 3: timestamp valid

#define WR_ENDPOINT             0x650c2d4f                              // WR-endpoint
#define WR_ENDPOINT_MACHI       0x24                                    // MAC high bytes
#define WR_ENDPOINT_MACLO       0x28                                    // MAC low bytes

#include "../../../ip_cores/saftlib/drivers/eca_flags.h"                // definitions for ECA queue

#include <wr-unipz.h>                                                   // defs
#include <wrunipz_shared_mmap.h>                                        // autogenerated upon building firmware


const char* dmunipz_state_text(uint32_t code) {
  switch (code) {
  case WRUNIPZ_STATE_UNKNOWN      : return "UNKNOWN   ";
  case WRUNIPZ_STATE_S0           : return "S0        ";
  case WRUNIPZ_STATE_IDLE         : return "IDLE      ";                                       
  case WRUNIPZ_STATE_CONFIGURED   : return "CONFIGURED";
  case WRUNIPZ_STATE_OPREADY      : return "opReady   ";
  case WRUNIPZ_STATE_STOPPING     : return "STOPPING  ";
  case WRUNIPZ_STATE_ERROR        : return "ERROR     ";
  case WRUNIPZ_STATE_FATAL        : return "FATAL(RIP)";
  default                         : return "undefined ";
  }
}

// stuff required for environment
extern uint32_t* _startshared[];
unsigned int     cpuId, cpuQty;
#define  SHARED  __attribute__((section(".shared")))
uint64_t SHARED  dummy = 0;

// global variables 
volatile uint32_t *pECAQ;               // WB address of ECA queue
volatile uint32_t *pMILPiggy;           // WB address of MIL device bus (MIL piggy)
volatile uint32_t *pPPSGen;             // WB address of PPS Gen
volatile uint32_t *pWREp;               // WB address of WR Endpoint

volatile uint32_t *pShared;             // pointer to begin of shared memory region
uint32_t *pSharedVersion;               // pointer to a "user defined" u32 register; here: publish version
uint32_t *pSharedSumStatus;             // pointer to a "user defined" u32 register; here: publish OR of all (actual) error bits
uint32_t *pSharedNBadStatus;            // pointer to a "user defined" u32 register; here: publish # of bad status (=error) incidents
uint32_t *pSharedNBadState;             // pointer to a "user defined" u32 register; here: publish # of bad state (=FATAL, ERROR, UNKNOWN) incidents
volatile uint32_t *pSharedCmd;          // pointer to a "user defined" u32 register; here: get command from host
uint32_t *pSharedState;                 // pointer to a "user defined" u32 register; here: publish status
volatile uint32_t *pSharedData4EB;      // pointer to a n x u32 register; here: memory region for receiving EB return values
uint32_t *pSharedMacHi;                 // pointer to a "user defined" u32 register; here: high bits of MAC
uint32_t *pSharedMacLo;                 // pointer to a "user defined" u32 register; here: low bits of MAC
uint32_t *pSharedIp;                    // pointer to a "user defined" u32 register; here: IP
uint32_t *pSharedNCycle;                // pointer to a "user defined" u32 register; here: number of UNILAC cycles
uint32_t *pSharedTCycleAvg;             // pointer to a "user defined" u32 register; here: period of UNILAC cycle [us] (average over one second)
uint32_t *pSharedNMessageHi;            // pointer to a "user defined" u32 register; here: high bits # of messages
uint32_t *pSharedNMessageLo;            // pointer to a "user defined" u32 register; here: lo bits # of messages
uint32_t *pSharedMsgFreqAvg;            // pointer to a "user defined" u32 register; here: message rate (average over one second)
uint32_t *pSharedDtMax;                 // pointer to a "user defined" u32 register; here: max diff between deadline and time of dispatching
uint32_t *pSharedDtMin;                 // pointer to a "user defined" u32 register; here: min diff between deadline and time of dispatching
uint32_t *pSharedNLate;                 // pointer to a "user defined" u32 register; here: # late messages
uint32_t *pSharedVaccAvg;               // pointer to a "user defined" u32 register; here: virt accs played during past second
uint32_t *pSharedPzAvg;                 // pointer to a "user defined" u32 register; here: PZs used during the past second
uint32_t *pSharedMode;                  // pointer to a "user defined" u32 register; here: mode (see WRUNIPZ_MODE...)
uint32_t *pSharedTDiagHi;               // pointer to a "user defined" u32 register; here: time when diag was cleared, high bits
uint32_t *pSharedTDiagLo;               // pointer to a "user defined" u32 register; here: time when diag was cleared, low bits
uint32_t *pSharedTS0Hi;                 // pointer to a "user defined" u32 register; here: time when FW was in S0 state, high bits
uint32_t *pSharedTS0Lo;                 // pointer to a "user defined" u32 register; here: time when FW was in S0 state, low bits
uint32_t *pSharedConfStat;              // pointer to a "user defined" u32 register; here: status of config data transaction
uint32_t *pSharedConfVacc;              // pointer to a "user defined" u32 register; here: virt acc of config data
uint32_t *pSharedConfData;              // pointer to a "user defined" u32 register; here: config data
uint32_t *pSharedConfFlag;              // pointer to a "user defined" u32 register; here: config flags
uint32_t *pSharedConfPz;                // pointer to a "user defined" u32 register; here: PZ bit field (bit N is set: transsaction for PZ N)

uint32_t *pCpuRamExternal;              // external address (seen from host bridge) of this CPU's RAM            
uint32_t *pCpuRamExternalData4EB;       // external address (seen from host bridge) of this CPU's RAM: field for EB return values

uint32_t sumStatus;                     // all status infos are ORed bit-wise into sum status, sum status is then published
uint32_t nBadStatus;                    // # of bad status (=error) incidents
uint32_t nBadState;                     // # of bad state (=FATAL, ERROR, UNKNOWN) incidents
int32_t  dtMax;                         // dT max (deadline - dispatch time)
int32_t  dtMin;                         // dT min (deadline - dispatch time)
uint32_t nLate;                         // # of late messages
uint32_t vaccAvg;                       // virt accs played over the past second
uint32_t pzAvg;                         // PZs used over the past second
uint32_t mode;                          // 1: test mode
uint32_t nCycleAct;                     // number of cycles
uint32_t nCyclePrev;                    // previous number of cycles
uint64_t nMsgAct;                       // # of messages sent
uint64_t nMsgPrev;                      // previous number of messages
uint64_t tSyncPrev;                     // timestamp of previous 50Hz sync event from SPZ
uint64_t lengthPrev;                    // duration of previous UNILAC cycle    



// big data contains the event tables for all PZs, and for all virtual accelerators
// there are two sets of 16 virtual accelerators ('Kanal0' and 'Kanal1')
dataTable bigData[WRUNIPZ_NPZ][WRUNIPZ_NVACC * WRUNIPZ_NCHN];
uint32_t  vaccNext[WRUNIPZ_NPZ];

uint32_t gid[] =                 {1000, 1001, 1002, 1003, 1004, 1005, 1006};              /* hackish: GIDs for PZs, to be clarified with Hanno */
                                                                        
uint64_t wrGetMac() // get my own MAC
{
  uint32_t macHi, macLo;
  uint64_t mac;

  macHi = (*(pWREp + (WR_ENDPOINT_MACHI >> 2))) & 0xffff;
  macLo = *(pWREp + (WR_ENDPOINT_MACLO >> 2));

  mac = macHi;
  mac = (mac << 32);
  mac = mac + macLo;

  return mac;
} // wrGetMac


uint32_t ebmInit(uint32_t msTimeout, uint64_t dstMac, uint32_t dstIp, uint32_t eb_ops) // intialize Etherbone master
{
  uint64_t timeoutT;

  // check IP
  timeoutT = getSysTime() + (uint64_t)msTimeout * (uint64_t)1000000;
  while (timeoutT < getSysTime()) {
    if (*(pEbCfg + (EBC_SRC_IP>>2)) == EBC_DEFAULT_IP) asm("nop");
    else break;
  } // while no IP via DHCP
  if (*(pEbCfg + (EBC_SRC_IP>>2)) == EBC_DEFAULT_IP) return WRUNIPZ_STATUS_NOIP;

  // init ebm
  ebm_init();
  ebm_config_if(DESTINATION, dstMac    , dstIp,                       0xebd0); 
  ebm_config_if(SOURCE,      wrGetMac(), *(pEbCfg + (EBC_SRC_IP>>2)), 0xebd0); 
  ebm_config_meta(1500, 0x0, eb_ops);
  ebm_clr();

  return WRUNIPZ_STATUS_OK;
} // ebminit


uint32_t data2TM(uint32_t *idLo, uint32_t *idHi, uint32_t *paramLo, uint32_t *paramHi, uint32_t *res, uint32_t *tef, uint32_t *offset, uint32_t data, uint32_t gid, uint32_t virtAcc)  //converts event UNILAC event data to timing message
{
  uint32_t  t;
  uint32_t  evtCode;
  uint32_t  status;

  t        = (uint32_t)((data >> 16) & 0xffff);      // get time relative to begining of UNILAC cycle [us]
  evtCode  = (uint32_t)(data & 0xff);                // get event number
  status   = (uint32_t)((data >> 6) & 0xff);         // get status info

  *idHi     = (uint32_t)(                            // EventID
                          0x1     << 28     |        // FID = 1
                         (gid     << 16)    |        // GID
                         (evtCode <<  4)    |        // EVTNO
                          0x0                        // flags
                        );
  *idLo     = (uint32_t)(
                         (virtAcc << 20)    |        // SID
                         (0x0     <<  6)    |        // BPID
                         (0x0     <<  5)    |        // reserved
                         (0x0     <<  4)    |        // reqNoBeam
                          0x0                        // virtAcc only for DM-UNIPZ gateway
                        );
  *paramLo  = status;                                // parameter field  /* chk, probably rquires Hanno */ 
  *paramHi  = 0x0;                                
  *res      = 0x0;                                   // reserved
  *tef      = 0x0;                                   // timing extension field
  *offset   = t * 1000;                              // convert offset -> ns
} // data2TM


uint32_t ebmWriteTM(dataTable evts, uint64_t tStart, uint32_t pz, uint32_t virtAcc, uint32_t isPrep)
{
  int      i;
  uint64_t deadline;
  uint32_t res, tef;
  uint32_t deadlineLo, deadlineHi, offset;
  uint32_t idLo, idHi;
  uint32_t paramLo, paramHi;
  int32_t  tDiff;

  // set high bits for EB master
  ebm_hi(WRUNIPZ_ECA_ADDRESS);

  // pack Ethernet frame with messages
  for (i=0; i<WRUNIPZ_NEVT; i++) {                     // loop over all data fields
    if ((evts.validFlags >> i) & 0x1) {                // data is valid?
      if ((evts.evtFlags >> i) & 0x1) {                // data is an event?
        if (((evts.prepFlags >> i) & 0x1) == isPrep) { // data matches 'isPrep condition'
          // convert data
          data2TM(&idLo, &idHi, &paramLo, &paramHi, &res, &tef, &offset, evts.data[i], gid[pz], virtAcc);  //convert data
            
          // calc deadline
          deadline   = tStart + (uint64_t)offset; 
          deadlineHi = (uint32_t)((deadline >> 32) & 0xffffffff);
          deadlineLo = (uint32_t)(deadline & 0xffffffff);
          
          // pack timing message
          atomic_on();                                  
          ebm_op(WRUNIPZ_ECA_ADDRESS, idHi,       EBM_WRITE);             
          ebm_op(WRUNIPZ_ECA_ADDRESS, idLo,       EBM_WRITE);             
          ebm_op(WRUNIPZ_ECA_ADDRESS, paramHi,    EBM_WRITE);
          ebm_op(WRUNIPZ_ECA_ADDRESS, paramLo,    EBM_WRITE);
          ebm_op(WRUNIPZ_ECA_ADDRESS, tef,        EBM_WRITE);
          ebm_op(WRUNIPZ_ECA_ADDRESS, res,        EBM_WRITE);
          ebm_op(WRUNIPZ_ECA_ADDRESS, deadlineHi, EBM_WRITE);
          ebm_op(WRUNIPZ_ECA_ADDRESS, deadlineLo, EBM_WRITE);
          atomic_off();

          // send timing message
          ebm_flush();
          
          // diag and status
          tDiff = deadline - getSysTime();
          if (tDiff < 0    ) nLate++;
          if (tDiff < dtMin) dtMin = tDiff;
          if (tDiff > dtMax) dtMax = tDiff;

          vaccAvg = vaccAvg | (1 << virtAcc);
          pzAvg   = pzAvg   | (1 << pz);
          nMsgAct++;
        } // if 'isPrep'
      } // is event
    } // is valid
  } // for i

  return WRUNIPZ_STATUS_OK;
} //ebmWriteTM


uint32_t wrCheckSyncState() //check status of White Rabbit (link up, tracking)
{
  uint32_t syncState;

  syncState =  *(pPPSGen + (WR_PPS_GEN_ESCR >> 2));                         // read status
  syncState = syncState & WR_PPS_GEN_ESCR_MASK;                             // apply mask

  if ((syncState == WR_PPS_GEN_ESCR_MASK)) return WRUNIPZ_STATUS_OK;        // check if all relevant bits are set
  else                                     return WRUNIPZ_STATUS_WRBADSYNC;
} //wrCheckStatus


void init() // typical init for lm32
{
  discoverPeriphery();        // mini-sdb ...
  uart_init_hw();             // needed by WR console   
  cpuId = getCpuIdx();

  timer_init(1);              // needed by usleep_init() 
  usleep_init();              // needed by scu_mil.c

  // set MSI IRQ handler
  isr_table_clr();
  //irq_set_mask(0x01);
  irq_disable();
} // init


void initSharedMem() // determine address and clear shared mem
{
  uint32_t idx;
  uint32_t *pSharedTemp;
  int      i; 
  const uint32_t c_Max_Rams = 10;
  sdb_location found_sdb[c_Max_Rams];
  sdb_location found_clu;
  
  // get pointer to shared memory
  pShared           = (uint32_t *)_startshared;

  // get address to data
  pSharedVersion          = (uint32_t *)(pShared + (WRUNIPZ_SHARED_VERSION >> 2));
  pSharedSumStatus        = (uint32_t *)(pShared + (WRUNIPZ_SHARED_SUMSTATUS >> 2));
  pSharedCmd              = (uint32_t *)(pShared + (WRUNIPZ_SHARED_CMD >> 2));
  pSharedState            = (uint32_t *)(pShared + (WRUNIPZ_SHARED_STATE >> 2));
  pSharedData4EB          = (uint32_t *)(pShared + (WRUNIPZ_SHARED_DATA_4EB >> 2));
  pSharedNBadStatus       = (uint32_t *)(pShared + (WRUNIPZ_SHARED_NBADSTATUS >> 2));
  pSharedNBadState        = (uint32_t *)(pShared + (WRUNIPZ_SHARED_NBADSTATE >> 2));
  pSharedMacHi            = (uint32_t *)(pShared + (WRUNIPZ_SHARED_MACHI >> 2));
  pSharedMacLo            = (uint32_t *)(pShared + (WRUNIPZ_SHARED_MACLO >> 2));
  pSharedIp               = (uint32_t *)(pShared + (WRUNIPZ_SHARED_IP >> 2));
  pSharedNCycle           = (uint32_t *)(pShared + (WRUNIPZ_SHARED_NCYCLE >> 2));  
  pSharedTCycleAvg        = (uint32_t *)(pShared + (WRUNIPZ_SHARED_TCYCLEAVG >> 2));
  pSharedNMessageHi       = (uint32_t *)(pShared + (WRUNIPZ_SHARED_NMESSAGEHI >> 2));
  pSharedNMessageLo       = (uint32_t *)(pShared + (WRUNIPZ_SHARED_NMESSAGELO >> 2));
  pSharedMsgFreqAvg       = (uint32_t *)(pShared + (WRUNIPZ_SHARED_MSGFREQAVG >> 2));
  pSharedDtMax            = (uint32_t *)(pShared + (WRUNIPZ_SHARED_DTMAX >> 2));
  pSharedDtMin            = (uint32_t *)(pShared + (WRUNIPZ_SHARED_DTMIN >> 2));
  pSharedNLate            = (uint32_t *)(pShared + (WRUNIPZ_SHARED_NLATE >> 2));
  pSharedVaccAvg          = (uint32_t *)(pShared + (WRUNIPZ_SHARED_VACCAVG >> 2));
  pSharedPzAvg            = (uint32_t *)(pShared + (WRUNIPZ_SHARED_PZAVG >> 2));
  pSharedMode             = (uint32_t *)(pShared + (WRUNIPZ_SHARED_MODE >> 2));
  pSharedTDiagHi          = (uint32_t *)(pShared + (WRUNIPZ_SHARED_TDIAGHI >> 2));
  pSharedTDiagLo          = (uint32_t *)(pShared + (WRUNIPZ_SHARED_TDIAGLO >> 2));
  pSharedTS0Hi            = (uint32_t *)(pShared + (WRUNIPZ_SHARED_TS0HI >> 2));
  pSharedTS0Lo            = (uint32_t *)(pShared + (WRUNIPZ_SHARED_TS0LO >> 2));
  pSharedConfStat         = (uint32_t *)(pShared + (WRUNIPZ_SHARED_CONF_STAT >> 2));
  pSharedConfVacc         = (uint32_t *)(pShared + (WRUNIPZ_SHARED_CONF_VACC >> 2));
  pSharedConfData         = (uint32_t *)(pShared + (WRUNIPZ_SHARED_CONF_DATA >> 2));
  pSharedConfFlag         = (uint32_t *)(pShared + (WRUNIPZ_SHARED_CONF_FLAG >> 2));
  pSharedConfPz           = (uint32_t *)(pShared + (WRUNIPZ_SHARED_CONF_PZ >> 2));
  
  // find address of CPU from external perspective
  idx = 0;
  find_device_multi(&found_clu, &idx, 1, GSI, LM32_CB_CLUSTER);	
  idx = 0;
  find_device_multi_in_subtree(&found_clu, &found_sdb[0], &idx, c_Max_Rams, GSI, LM32_RAM_USER);
  if(idx >= cpuId) {
    pCpuRamExternal           = (uint32_t *)(getSdbAdr(&found_sdb[cpuId]) & 0x7FFFFFFF); // CPU sees the 'world' under 0x8..., remove that bit to get host bridge perspective
    pCpuRamExternalData4EB    = (uint32_t *)(pCpuRamExternal + ((WRUNIPZ_SHARED_DATA_4EB + SHARED_OFFS) >> 2));
  }

  DBPRINT2("wr-unipz: CPU RAM External 0x%8x, begin shared 0x%08x\n", pCpuRamExternal, SHARED_OFFS);

  // clear shared mem
  i = 0;
  pSharedTemp          = (uint32_t *)(pShared + (WRUNIPZ_SHARED_BEGIN >> 2 ));
  while (pSharedTemp < (uint32_t *)(pShared + (WRUNIPZ_SHARED_END >> 2 ))) {
    *pSharedTemp = 0x0;
    pSharedTemp++;
    i++;
  } // while pSharedTemp
  DBPRINT2("wr-unipz: used size of shared mem is %d words (uint32_t), begin %x, end %x\n", i, pShared, pSharedTemp-1);
  
  // set initial values;
  *pSharedVersion      = WRUNIPZ_FW_VERSION; // of all the shared variabes, only VERSION is a constant. Set it now!
  *pSharedNBadStatus   = 0;
  *pSharedNBadState    = 0;
  *pSharedConfStat     = WRUNIPZ_CONFSTAT_IDLE;
} // initSharedMem 


uint32_t findMILPiggy() //find WB address of MIL Piggy
{
  pMILPiggy = 0x0;
  
  // get Wishbone address for MIL Piggy
  pMILPiggy = find_device_adr(GSI, SCU_MIL);

  if (!pMILPiggy) {DBPRINT1("wr-unipz: can't find MIL piggy\n"); return WRUNIPZ_STATUS_ERROR;}
  else                                                           return WRUNIPZ_STATUS_OK;
} // findMILPiggy


uint32_t findPPSGen() //find WB address of WR PPS Gen
{
  pPPSGen = 0x0;
  
  // get Wishbone address for PPS Gen
  pPPSGen = find_device_adr(CERN, WR_PPS_GEN);

  if (!pPPSGen) {DBPRINT1("wr-unipz: can't find WR PPS Gen\n"); return WRUNIPZ_STATUS_ERROR;}
  else                                                          return WRUNIPZ_STATUS_OK;
} // findPPSGen


uint32_t findWREp() //find WB address of WR Endpoint
{
  pWREp = 0x0;
  
  // get Wishbone address for WR Endpoint
  pWREp = find_device_adr(CERN, WR_ENDPOINT);

  if (!pWREp) {DBPRINT1("wr-unipz: can't find WR Endpoint\n"); return WRUNIPZ_STATUS_ERROR;}
  else                                                         return WRUNIPZ_STATUS_OK;
} // findWREp


uint32_t findECAQueue() // find WB address of ECA channel for LM32
{
#define ECAQMAX           4     // max number of ECA channels in the system
#define ECACHANNELFORLM32 2     // this is a hack! suggest implementing finding via sdb-record and info

  // stuff below needed to get WB address of ECA queue
  sdb_location ECAQ_base[ECAQMAX];
  uint32_t ECAQidx = 0;         
  uint32_t *tmp;                
  int i;

  // get Wishbone address of ECA queue 
  // get list of ECA queues
  find_device_multi(ECAQ_base, &ECAQidx, ECAQMAX, ECA_QUEUE_SDB_VENDOR_ID, ECA_QUEUE_SDB_DEVICE_ID);
  pECAQ = 0x0;

  // find ECA queue connected to ECA chanel for LM32
  for (i=0; i < ECAQidx; i++) {
    tmp = (uint32_t *)(getSdbAdr(&ECAQ_base[i]));  
    if ( *(tmp + (ECA_QUEUE_QUEUE_ID_GET >> 2)) == ECACHANNELFORLM32) pECAQ = tmp;
  }

  if (!pECAQ) {DBPRINT1("wr-unipz: can't find ECA queue\n"); return WRUNIPZ_STATUS_ERROR;}
  else                                                       return WRUNIPZ_STATUS_OK;
} // findECAQueue


uint32_t wait4ECAEvent(uint32_t msTimeout, uint64_t *deadline, uint32_t *isLate)  // 1. query ECA for actions, 2. trigger activity
{
  uint32_t *pECAFlag;           // address of ECA flag
  uint32_t evtIdHigh;           // high 32bit of eventID   
  uint32_t evtIdLow;            // low 32bit of eventID    
  uint32_t evtDeadlHigh;        // high 32bit of deadline  
  uint32_t evtDeadlLow;         // low 32bit of deadline   
  uint32_t evtParamHigh;        // high 32 bit of parameter field
  uint32_t evtParamLow ;        // low 32 bit of parameter field
  uint32_t evtTef;              // 32 bit TEF field
  uint32_t actTag;              // tag of action           
  uint32_t nextAction;          // describes what to do next
  uint64_t timeoutT;            // when to time out

  /*
  if (mode == WRUNIPZ_MODE_TEST) {
  // hackish implementation of a test mode without events from Super-UNIPZ
  uint64_t tCycle;              // UNILAC period
  uint64_t tEntry;              // timestamp when entering this routine
  uint64_t tNext;               // timestamp of next 20ms tick
  uint64_t nCycles;             // number of 20ms cycles

  tCycle  = 20000000;
  tEntry  = getSysTime();
  nCycles = tEntry / tCycle;    // number of UNILAC cycles so far
  nCycles = nCycles + 1;        // number of next UNILAC cycle
  tNext   = tCycle * nCycles;

  while (getSysTime() < tNext) asm("nop");

  *deadline = tNext;
  *isLate   = 0;
  
  return WRUNIPZ_ECADO_TEST;
  } // if mode
  */

  pECAFlag    = (uint32_t *)(pECAQ + (ECA_QUEUE_FLAGS_GET >> 2));   // address of ECA flag

  timeoutT    = getSysTime() + (uint64_t)msTimeout * (uint64_t)1000000 + (uint64_t)1000; 
  
  while (getSysTime() < timeoutT) {
    if (*pECAFlag & (0x0001 << ECA_VALID)) {                        // if ECA data is valid

      // read data
      evtIdHigh    = *(pECAQ + (ECA_QUEUE_EVENT_ID_HI_GET >> 2));
      evtIdLow     = *(pECAQ + (ECA_QUEUE_EVENT_ID_LO_GET >> 2));
      evtDeadlHigh = *(pECAQ + (ECA_QUEUE_DEADLINE_HI_GET >> 2));
      evtDeadlLow  = *(pECAQ + (ECA_QUEUE_DEADLINE_LO_GET >> 2));
      actTag       = *(pECAQ + (ECA_QUEUE_TAG_GET >> 2));
      evtParamHigh = *(pECAQ + (ECA_QUEUE_PARAM_HI_GET >> 2));
      evtParamLow  = *(pECAQ + (ECA_QUEUE_PARAM_LO_GET >> 2));
      evtTef       = *(pECAQ + (ECA_QUEUE_TEF_GET >> 2));
      *isLate      = *pECAFlag & (0x0001 << ECA_LATE);

      *deadline    = ((uint64_t)evtDeadlHigh << 32) + (uint64_t)evtDeadlLow;
      
      // pop action from channel
      *(pECAQ + (ECA_QUEUE_POP_OWR >> 2)) = 0x1;

      // here: do s.th. according to tag
      switch (actTag) 
        {
        case WRUNIPZ_ECADO_MIL :
          nextAction = WRUNIPZ_ECADO_MIL;
          break;
        default: 
          nextAction = WRUNIPZ_ECADO_UNKOWN;
          break;
        } // switch

      return nextAction;

    } // if data is valid
  } // while not timed out

  return  WRUNIPZ_ECADO_TIMEOUT;
} // wait for ECA event


void initCmds() // init stuff for handling commands, trivial for now, will be extended
{
  //  initalize command value: 0x0 means 'no command'
  *pSharedCmd     = 0x0;
} // initCmds

 
uint32_t configMILEvent() // configure SoC to receive events via MIL bus
{
  uint32_t i;

  // initialize status and command register with initial values; disable event filtering; clear filter RAM
  if (writeCtrlStatRegEvtMil(pMILPiggy, MIL_CTRL_STAT_ENDECODER_FPGA | MIL_CTRL_STAT_INTR_DEB_ON) != MIL_STAT_OK) return WRUNIPZ_STATUS_ERROR; //chk sure we go for status error?

  // clean up 
  if (disableLemoEvtMil(pMILPiggy, 1) != MIL_STAT_OK) return WRUNIPZ_STATUS_ERROR;
  if (disableLemoEvtMil(pMILPiggy, 2) != MIL_STAT_OK) return WRUNIPZ_STATUS_ERROR;
  if (disableFilterEvtMil(pMILPiggy)  != MIL_STAT_OK) return WRUNIPZ_STATUS_ERROR; 
  if (clearFilterEvtMil(pMILPiggy)    != MIL_STAT_OK) return WRUNIPZ_STATUS_ERROR; 

  for (i=0; i < (0xf+1); i++) {
    // set filter for all possible virtual accelerators; set filter and LEMO for 50 Hz sync
    if (setFilterEvtMil(pMILPiggy, WRUNIPZ_EVT_50HZ_SYNCH, i, MIL_FILTER_EV_TO_FIFO | MIL_FILTER_EV_PULS1_S) != MIL_STAT_OK) return WRUNIPZ_STATUS_ERROR;
    if (setFilterEvtMil(pMILPiggy, WRUNIPZ_EVT_PZ1       , i, MIL_FILTER_EV_TO_FIFO                        ) != MIL_STAT_OK) return WRUNIPZ_STATUS_ERROR;
    if (setFilterEvtMil(pMILPiggy, WRUNIPZ_EVT_PZ2       , i, MIL_FILTER_EV_TO_FIFO                        ) != MIL_STAT_OK) return WRUNIPZ_STATUS_ERROR;
    if (setFilterEvtMil(pMILPiggy, WRUNIPZ_EVT_PZ3       , i, MIL_FILTER_EV_TO_FIFO                        ) != MIL_STAT_OK) return WRUNIPZ_STATUS_ERROR;
    if (setFilterEvtMil(pMILPiggy, WRUNIPZ_EVT_PZ4       , i, MIL_FILTER_EV_TO_FIFO                        ) != MIL_STAT_OK) return WRUNIPZ_STATUS_ERROR;
    if (setFilterEvtMil(pMILPiggy, WRUNIPZ_EVT_PZ5       , i, MIL_FILTER_EV_TO_FIFO                        ) != MIL_STAT_OK) return WRUNIPZ_STATUS_ERROR;
    if (setFilterEvtMil(pMILPiggy, WRUNIPZ_EVT_PZ6       , i, MIL_FILTER_EV_TO_FIFO                        ) != MIL_STAT_OK) return WRUNIPZ_STATUS_ERROR;
    if (setFilterEvtMil(pMILPiggy, WRUNIPZ_EVT_PZ7       , i, MIL_FILTER_EV_TO_FIFO                        ) != MIL_STAT_OK) return WRUNIPZ_STATUS_ERROR;
  }

  // configure LEMO1 for pulse generation
  if (configLemoPulseEvtMil(pMILPiggy, 1) != MIL_STAT_OK) return WRUNIPZ_STATUS_ERROR;

  return WRUNIPZ_STATUS_OK;
} // configMILEvent


 uint32_t wait4MILEvent(uint16_t *evtData, uint16_t *evtCode, uint32_t *virtAcc, uint32_t msTimeout)  // wait for MIL event or timeout
{
  uint32_t evtRec;             // one MIL event
  uint32_t evtCodeRec;         // "event number"
  uint32_t evtDataRec;         // "event data"
  uint32_t virtAccRec;         // "virt Acc"
  uint64_t timeoutT;           // when to time out
  int      valid;              // evt is valid

  timeoutT    = getSysTime() + (uint64_t)msTimeout * (uint64_t)1000000;
  *virtAcc    = 0xffff;           
  *evtData    = 0xffff;
  *evtCode    = 0xffff;
  valid       = 0;
  
  while(getSysTime() < timeoutT) {              // while not timed out...
    while (fifoNotemptyEvtMil(pMILPiggy)) {     // while fifo contains data
      popFifoEvtMil(pMILPiggy, &evtRec);    
      evtCodeRec  = evtRec & 0x000000ff;        // extract event code
      virtAccRec  = (evtRec >> 8)  & 0x0f;      // extract virtual accelerator
      evtDataRec  = (evtRec >> 12) & 0x0f;      // extract event data

      //mprintf("data %d, code %d, vA %d\n", evtDataRec, evtCodeRec, virtAccTmp);

      switch (evtCodeRec) {
      case WRUNIPZ_EVT_PZ1 ... WRUNIPZ_EVT_PZ7 : valid = 1; break;
      case WRUNIPZ_EVT_SYNCH_DATA              : valid = 1; break;
      case WRUNIPZ_EVT_50HZ_SYNCH              : valid = 1; break;
      default                                  : break;
      } // switch event code

      if (valid) {
        *evtData     = evtDataRec;
        *evtCode     = evtCodeRec;
        *virtAcc     = virtAccRec;
        return WRUNIPZ_STATUS_OK;
      } // if valid;
    } // while fifo contains data
    asm("nop");                                 // wait a bit...
  } // while not timed out

  return WRUNIPZ_STATUS_TIMEDOUT;  
} //wait4MILEvent


void pulseLemo2() //for debugging with scope
{
  uint32_t i;

  setLemoOutputEvtMil(pMILPiggy, 2, 1);
  for (i=0; i< 10 * WRUNIPZ_US_ASMNOP; i++) asm("nop");
  setLemoOutputEvtMil(pMILPiggy, 2, 0);
} // pulseLemo2


void clearDiag() // clears all statistics
{
  uint64_t now;
  
  dtMax          = 0x80000000;
  dtMin          = 0x7fffffff;
  nLate          = 0;
  nCycleAct      = 0;
  nCyclePrev     = 0;
  nMsgAct        = 0;
  nMsgPrev       = 0;
  sumStatus      = 0;
  nBadStatus     = 0;

  now = getSysTime();
  *pSharedTDiagHi = (uint32_t)(now >> 32);
  *pSharedTDiagLo = (uint32_t)now & 0xffffffff;

} // clearDiag

uint32_t configTransactInit()          // initializes transaction for config data
{
  int i,j;
  
  if (*pSharedConfStat != WRUNIPZ_CONFSTAT_IDLE) return WRUNIPZ_STATUS_TRANSACTION;

  *pSharedConfPz    = 0;
  *pSharedConfVacc  = 0;
  for (i=0; i < (WRUNIPZ_NCONFFLAG); i++) *(pSharedConfFlag   + i) = 0;
  for (i=0; i < (WRUNIPZ_NCONFDATA); i++) *(pSharedConfData   + i) = 0;

  DBPRINT2("wr-unipz: request completed\n");
    
  *pSharedConfStat = WRUNIPZ_CONFSTAT_INIT;

  return WRUNIPZ_STATUS_OK;
} // configTransactInit

uint32_t configTransactSubmit() // submit transferred config data
{
  if (*pSharedConfStat != WRUNIPZ_CONFSTAT_INIT) return WRUNIPZ_STATUS_TRANSACTION;

  /* hack: code below shall be triggered by "commit" event from Masterpulszentrale */
  int      i,j,k;
  int      vacc;
  uint32_t pzFlag;

  // get vacc and submit flags
  vacc    = *pSharedConfVacc;
  pzFlag  = *pSharedConfPz;

  for (i=0; i < WRUNIPZ_NPZ; i++) {        // for all Pulszentralen
    for (j=0; j < WRUNIPZ_NCHN; j++) {     // for all channels
      if (pzFlag & (1 << i)) {             // check, if Pulszentrale (defined by "i") shall be submitted
        // flags
        bigData[i][j * WRUNIPZ_NVACC + vacc].validFlags = *(pSharedConfFlag + j * WRUNIPZ_NFLAG + i * WRUNIPZ_NPZ * WRUNIPZ_NCHN + 0);
        bigData[i][j * WRUNIPZ_NVACC + vacc].prepFlags  = *(pSharedConfFlag + j * WRUNIPZ_NFLAG + i * WRUNIPZ_NPZ * WRUNIPZ_NCHN + 1);
        bigData[i][j * WRUNIPZ_NVACC + vacc].evtFlags   = *(pSharedConfFlag + j * WRUNIPZ_NFLAG + i * WRUNIPZ_NPZ * WRUNIPZ_NCHN + 2);

        // data
        for (k=0; k < WRUNIPZ_NEVT; k++) 
          bigData[i][j * WRUNIPZ_NVACC + vacc].data[k]  = *(pSharedConfData + j * WRUNIPZ_NEVT  + i * WRUNIPZ_NEVT * WRUNIPZ_NCHN + k);
      } // if submit flag
    } // for j
  } // for i
  /* end hack */

  DBPRINT2("wr-unipz: submit completed\n");
  
  /* *pSharedConfDataStat = WRUNIPZ_CONFSTAT_REQ | WRUNIPZ_CONFSTAT_SUBMIT; commented: this shall be used once code above is triggered by event */
  *pSharedConfStat = WRUNIPZ_CONFSTAT_IDLE;

  return WRUNIPZ_STATUS_OK;
} // configTransactSubmit


void clearPZ()
{
  int i,j,k;

  for (i=0; i < WRUNIPZ_NPZ; i++)
    for (j=0; j < (WRUNIPZ_NVACC * WRUNIPZ_NCHN); j++) {
      bigData[i][j].validFlags = 0x0;
      bigData[i][j].prepFlags  = 0x0;
      bigData[i][j].evtFlags   = 0x0;
      for (k=0; k < WRUNIPZ_NEVT; k++) bigData[i][j].data[k] = 0x0;
    } // for j
} // clear PZ


uint32_t doActionS0()
{
  uint32_t status = WRUNIPZ_STATUS_OK;
  uint64_t now;

  if (findECAQueue() != WRUNIPZ_STATUS_OK) status = WRUNIPZ_STATUS_ERROR; 
  if (findMILPiggy() != WRUNIPZ_STATUS_OK) status = WRUNIPZ_STATUS_ERROR;
  if (findPPSGen()   != WRUNIPZ_STATUS_OK) status = WRUNIPZ_STATUS_ERROR;
  if (findWREp()     != WRUNIPZ_STATUS_OK) status = WRUNIPZ_STATUS_ERROR;

  nBadState     = 0;
  mode          = WRUNIPZ_MODE_SPZ;
  now           = getSysTime();
  *pSharedTS0Hi = (uint32_t)(now >> 32);
  *pSharedTS0Lo = (uint32_t)now & 0xffffffff;
  
  initCmds();                    

  return status;
} // doActionS0


uint32_t entryActionConfigured()
{
  uint32_t status = WRUNIPZ_STATUS_OK;
  uint64_t mac;
  uint32_t ip;

  // configure EB master (SRC and DST MAC/IP are set from host)
  //  ebmInit(100, 0xffffffffffff, 0xffffffff, EBM_NOREPLY);
  if ((status = ebmInit(2000, 0xffffffffffff, 0xffffffff, EBM_NOREPLY)) != WRUNIPZ_STATUS_OK) {
    DBPRINT1("wr-unipz: ERROR - init of EB master failed! %d\n", status);
    return status;
  } 

  // get and publish NIC data
  mac = wrGetMac();
  *pSharedMacHi = (uint32_t)(mac >> 32) & 0xffff;
  *pSharedMacLo = (uint32_t)mac         & 0xffffffff;

  ip  = *(pEbCfg + (EBC_SRC_IP>>2));
  *pSharedIp    = ip;

  // reset MIL piggy and wait
  if ((status = resetPiggyDevMil(pMILPiggy))  != MIL_STAT_OK) {
    DBPRINT1("wr-unipz: ERROR - can't reset MIL Piggy\n");
    return WRUNIPZ_STATUS_MIL;
  } 
  
  // configure MIL piggy for timing events for all 16 virtual accelerators
  if ((status = configMILEvent()) != WRUNIPZ_STATUS_OK) {
    DBPRINT1("wr-unipz: ERROR - failed to configure MIL piggy for receiving timing events! %d\n", status);
    return status;
  } 

  DBPRINT1("wr-unipz: MIL piggy configured for receving events (eventbus)\n");

  configLemoOutputEvtMil(pMILPiggy, 2);    // used to see a blinking LED (and optionally connect a scope) for debugging
  
  *pSharedConfStat = WRUNIPZ_CONFSTAT_IDLE; /* chk */
  mode             = WRUNIPZ_MODE_SPZ;
  return status;
} // entryActionConfigured


uint32_t entryActionOperation()
{
  int      i;
  uint64_t tDummy;
  uint32_t flagDummy;
  
  clearDiag();                                               // clear diagnostics
  clearPZ();                                                 // clear all event tables
  for (i=0; i < WRUNIPZ_NPZ; i++) vaccNext[i] = 0xffffffff;  // 0xffffffff: no virt acc
  enableFilterEvtMil(pMILPiggy);                             // enable MIL event filter
  clearFifoEvtMil(pMILPiggy);                                // clear MIL event FIFO

  // flush ECA queue for lm32
  i = 0;
  while (wait4ECAEvent(1, &tDummy, &flagDummy) !=  WRUNIPZ_ECADO_TIMEOUT) {i++;}
  DBPRINT1("wr-unipz: ECA queue flushed - removed %d pending entries from ECA queue\n", i);

  return WRUNIPZ_STATUS_OK;
} // entryActionOperation


uint32_t exitActionOperation(){
  if (disableFilterEvtMil(pMILPiggy) != MIL_STAT_OK) return WRUNIPZ_STATUS_ERROR; 
  
  return WRUNIPZ_STATUS_OK;
} // exitActionOperation

uint32_t exitActionError()
{
  return WRUNIPZ_STATUS_OK;
} // exitActionError


void cmdHandler(uint32_t *reqState) // handle commands from the outside world
{
  uint32_t cmd;

  cmd = *pSharedCmd;
  // check, if the command is valid and request state change
  if (cmd) {
    switch (cmd) {
    case WRUNIPZ_CMD_CONFIGURE :
      *reqState =  WRUNIPZ_STATE_CONFIGURED;
      DBPRINT3("wr-unipz: received cmd %d\n", cmd);
      break;
    case WRUNIPZ_CMD_STARTOP :
      *reqState = WRUNIPZ_STATE_OPREADY;
      DBPRINT3("wr-unipz: received cmd %d\n", cmd);
      break;
    case WRUNIPZ_CMD_STOPOP :
      *reqState = WRUNIPZ_STATE_STOPPING;
      DBPRINT3("wr-unipz: received cmd %d\n", cmd);
      break;
    case WRUNIPZ_CMD_IDLE :
      *reqState = WRUNIPZ_STATE_IDLE;
      DBPRINT3("wr-unipz: received cmd %d\n", cmd);
      break;
    case WRUNIPZ_CMD_RECOVER :
      *reqState = WRUNIPZ_STATE_IDLE;
      DBPRINT3("wr-unipz: received cmd %d\n", cmd);
      break;
    case WRUNIPZ_CMD_CLEARDIAG :
      DBPRINT3("wr-unipz: received cmd %d\n", cmd);
      clearDiag();
      break;
    case WRUNIPZ_CMD_CONFINIT :
      DBPRINT3("wr-unipz: received cmd %d\n", cmd);
      if (configTransactInit() != WRUNIPZ_STATUS_OK) DBPRINT1("wr-unipz: request to start config data transaction failed\n");
      break;
    case WRUNIPZ_CMD_CONFSUBMIT :
      DBPRINT3("wr-unipz: received cmd %d\n", cmd);
      if (configTransactSubmit() != WRUNIPZ_STATUS_OK) DBPRINT1("wr-unipz: submission of config data failed\n");
      break;
    case WRUNIPZ_CMD_CONFKILL :
      DBPRINT3("wr-unipz: received cmd %d\n", cmd);
      *pSharedConfStat = WRUNIPZ_CONFSTAT_IDLE;
      break;     
    case WRUNIPZ_CMD_CONFCLEAR :
      DBPRINT3("wr-unipz: received cmd %d\n", cmd);
      clearPZ();
      break;
    case WRUNIPZ_CMD_MODESPZ :
      DBPRINT3("wr-unipz: received cmd %d\n", cmd);
      mode = WRUNIPZ_MODE_SPZ;
      break;
    case WRUNIPZ_CMD_MODETEST :
      DBPRINT3("wr-unipz: received cmd %d\n", cmd);
      mode = WRUNIPZ_MODE_TEST;
      break;
    default:
      DBPRINT3("wr-unipz: received unknown command '0x%08x'\n", cmd);
    } // switch 
    *pSharedCmd = 0x0; // reset cmd value in shared memory 
  } // if command 
} // cmdHandler


uint32_t changeState(uint32_t *actState, uint32_t *reqState, uint32_t actStatus)   //state machine; see wr-unipz.h for possible states and transitions
{
  uint32_t statusTransition= WRUNIPZ_STATUS_OK;
  uint32_t status;
  uint32_t nextState;                   

  // if something severe happened, perform implicitely allowed transition to ERROR or FATAL states
  // else                        , handle explicitcely allowed transitions

  if ((*reqState == WRUNIPZ_STATE_ERROR) || (*reqState == WRUNIPZ_STATE_FATAL)) {statusTransition = actStatus; nextState = *reqState;}
  else {
    nextState = *actState;                       // per default: remain in actual state without exit or entry action
    switch (*actState) {                         // check for allowed transitions: 1. determine next state, 2. perform exit or entry actions if required
    case WRUNIPZ_STATE_S0:
      if      (*reqState == WRUNIPZ_STATE_IDLE)       {                                            nextState = *reqState;}      
      break;
    case WRUNIPZ_STATE_IDLE:
      if      (*reqState == WRUNIPZ_STATE_CONFIGURED)  {statusTransition = entryActionConfigured(); nextState = *reqState;}
      break;
    case WRUNIPZ_STATE_CONFIGURED:
      if      (*reqState == WRUNIPZ_STATE_IDLE)       {                                            nextState = *reqState;}
      else if (*reqState == WRUNIPZ_STATE_CONFIGURED) {statusTransition = entryActionConfigured(); nextState = *reqState;}
      else if (*reqState == WRUNIPZ_STATE_OPREADY)    {statusTransition = entryActionOperation();  nextState = *reqState;}
      break;
    case WRUNIPZ_STATE_OPREADY:
      if      (*reqState == WRUNIPZ_STATE_STOPPING)   {statusTransition = exitActionOperation();   nextState = *reqState;}
      break;
    case WRUNIPZ_STATE_STOPPING:
      nextState = WRUNIPZ_STATE_CONFIGURED;      //automatic transition but without entryActionConfigured
    case WRUNIPZ_STATE_ERROR:
      if      (*reqState == WRUNIPZ_STATE_IDLE)       {statusTransition = exitActionError();       nextState = *reqState;}
      break;
    default: 
      nextState = WRUNIPZ_STATE_S0;
    } // switch actState
  }  // else something severe happened
  
  // if the transition failed, transit to error state (except we are already in FATAL state)
  if ((statusTransition != WRUNIPZ_STATUS_OK) && (nextState != WRUNIPZ_STATE_FATAL)) nextState = WRUNIPZ_STATE_ERROR;

  // if the state changes
  if (*actState != nextState) {                   
    mprintf("wr-unipz: changed to state %d\n", nextState);
    *actState = nextState;                      
    status = statusTransition;
  } // if state change
  else  status = actStatus;

  *reqState = WRUNIPZ_STATE_UNKNOWN;             // reset requested state (= no change state requested)  

  return status;
} //changeState


uint32_t doActionOperation(uint32_t *nCycle,                  // total number of UNILAC cycle since FW start
                           uint64_t *tAct,                    // actual time
                           uint32_t actStatus)                // actual status of firmware
{
  uint32_t status;                                            // status returned by routines
  uint32_t flagIsLate;                                        // flag indicating that we received a 'late' event from ECA
  uint32_t ecaAction;                                         // action triggered by event received from ECA
  uint64_t deadline;                                          // deadline of event received via ECA
  uint64_t tMIL;                                              // time when MIL event was received
  uint64_t tDummy;                                            // dummy timestamp
  uint16_t evtData;                                           // MIL event: data
  uint16_t evtCode;                                           // MIL event: code
  uint32_t virtAcc;                                           // MIL event: virtAcc
  uint32_t milStatus;                                         // status for receiving of MIL events
  uint32_t nLateLocal;                                        // remember actual counter
  uint32_t isPrepFlag;                                        // flag 'isPrep': prep-events are sent immediately, non-prep-events are sent at 50 Hz trigger
  int      i,j;


  status = actStatus;
  
  // wait for MIL event
  milStatus = wait4MILEvent(&evtData, &evtCode, &virtAcc, WRUNIPZ_MILTIMEOUT);
  if (milStatus == WRUNIPZ_STATUS_TIMEDOUT) return WRUNIPZ_STATUS_NOMILEVENTS; // error: no MIL event, maybe dead UNIPZ?
  if (milStatus != WRUNIPZ_STATUS_OK)       return WRUNIPZ_STATUS_MIL;         // some other error

  tMIL      = getSysTime();

  switch (evtCode) {

  case WRUNIPZ_EVT_50HZ_SYNCH :                                // next UNILAC cycle starts
    (*nCycle)++;
    DBPRINT3("wr-unipz: 50Hz, data %d, evtcode %d, virtAcc %d\n", evtData, evtCode, virtAcc);

    // get timestamp from TLU -> ECA
    ecaAction = wait4ECAEvent(WRUNIPZ_ECATIMEOUT, &deadline, &flagIsLate);
    
    // check, if timestamping via TLU failed
    if (ecaAction == WRUNIPZ_ECADO_TIMEOUT) {      
      deadline = tMIL;                                          // continue with TS from MIL
      status   = WRUNIPZ_STATUS_NOTIMESTAMP;
    } // if ecaAction
    
    // check, if timestamps form TLU and MIL are out of order
    if (deadline > tMIL) {
      deadline = tMIL;                                          // continue with TS from MIL
      status   = WRUNIPZ_STATUS_ORDERTIMESTAMP;
    } // if deadline
    
    // check, if timestamp from TLU is not reasonable
    if ((tMIL - deadline) > WRUNIPZ_MATCHWINDOW) {
      deadline = tMIL;                                          // continue with TS from MIL
      status   = WRUNIPZ_STATUS_BADTIMESTAMP;
    } // if tMIL
    

    ebm_clr();

    // walk through all PZs and run requested virt acc (non-prep events)
    nLateLocal = nLate;                                        // for bookkepping for late messages
    lengthPrev = deadline - tSyncPrev;                         // required for 'prep events of next UNILAC cycle'
    tSyncPrev  = deadline;                                     // required for 'prep events of next UNILAC cycle'
    isPrepFlag = 0;                                            // 50 Hz synch: no preperation - use actual deadline from TLU
    for (i=0; i < WRUNIPZ_NPZ; i++) {
      if (vaccNext[i] != 0xffffffff) {
        ebmWriteTM(bigData[i][vaccNext[i]], deadline, i, vaccNext[i], isPrepFlag);
        DBPRINT3("wr-unipz: playing pz %d, vacc %d\n", i, vaccNext[i]);
      } // if vaccNext
    } // for i
    if ((nLate != nLateLocal) && (status == WRUNIPZ_STATUS_OK)) status = WRUNIPZ_STATUS_LATE;
    *tAct = deadline;                                           // remember 50 Hz tick
    DBPRINT3("wr-unipz: vA played:  %x %x %x %x %x %x %x\n", vaccNext[0], vaccNext[1], vaccNext[2], vaccNext[3], vaccNext[4], vaccNext[5], vaccNext[6]);

    // reset requested virt accs; flush ECA queue
    for (i=0; i < WRUNIPZ_NPZ; i++) vaccNext[i] = 0xffffffff;   // 0xffffffff: no virt acc for PZ
    DBPRINT3("wr-unipz: vA reset:  %x %x %x %x %x %x %x\n", vaccNext[0], vaccNext[1], vaccNext[2], vaccNext[3], vaccNext[4], vaccNext[5], vaccNext[6]);
    while (wait4ECAEvent(0, &tDummy, &flagIsLate) !=  WRUNIPZ_ECADO_TIMEOUT) {asm("nop");}
    
    break;
  case WRUNIPZ_EVT_PZ1 ... WRUNIPZ_EVT_PZ7 :                    // announce what happens in next UNILAC cycle
    vaccNext[evtCode-1] = virtAcc;                              // PZ: sPZ counts from 1..7, we count from 0..6
    DBPRINT3("wr-unipz: vA set:  %x %x %x %x %x %x %x\n", vaccNext[0], vaccNext[1], vaccNext[2], vaccNext[3], vaccNext[4], vaccNext[5], vaccNext[6]);

    nLateLocal = nLate;
    isPrepFlag = 1;                                             // PZ1..7: preperation - use deadline from past 50 Hz tick
    deadline   = tSyncPrev + (uint64_t)WRUNIPZ_UNILACPERIOD;
    ebmWriteTM(bigData[evtCode - 1][virtAcc], deadline, evtCode - 1, virtAcc, isPrepFlag);
    DBPRINT3("wr-unipz: playing pz %d, vacc %d\n", i, virtAcc);
    if ((nLate != nLateLocal) && (status == WRUNIPZ_STATUS_OK)) status = WRUNIPZ_STATUS_LATE;

    break;
  default :
    break;
  } // switch evtCode

  return status;
} // doActionOperation

uint32_t doAutoRecovery(uint32_t actState, uint32_t *reqState)                    // do autorecovery from error state
{
  switch (actState)
    {
    case WRUNIPZ_STATE_ERROR :
      DBPRINT3("wr-unipz: attempting autorecovery ERROR -> IDLE\n");
      usleep(10000000);
      *reqState = WRUNIPZ_STATE_IDLE; 
      break;
    case WRUNIPZ_STATE_IDLE :
      DBPRINT3("wr-unipz: attempting autorecovery IDLE -> CONFIGURED\n");
      usleep(5000000);
      *reqState =  WRUNIPZ_STATE_CONFIGURED;
      break;
    case WRUNIPZ_STATE_CONFIGURED :
      DBPRINT3("wr-unipz: attempting autorecovery CONFIGURED -> OPREADY\n");
      usleep(5000000);
      *reqState =  WRUNIPZ_STATE_OPREADY;
      break;
    default : ;
    } // switch actState
} // doAutoRecovery


void main(void) {
 
  uint32_t j;
 
  uint64_t tPrevCycle;                          // time of previous UNILAC cycle
  uint64_t tActCycle;                           // time of actual UNILAC cycle
  uint32_t status;                              // (error) status
  uint32_t actState;                            // actual FSM state
  uint32_t reqState;                            // requested FSM state
  uint32_t flagRecover;                         // flag indicating auto-recovery from error state;  

  mprintf("\n");
  mprintf("wr-unipz: ***** firmware v %06d started from scratch *****\n", WRUNIPZ_FW_VERSION);
  mprintf("\n");
  
  // init local variables
  reqState       = WRUNIPZ_STATE_S0;
  actState       = WRUNIPZ_STATE_UNKNOWN;
  status         = WRUNIPZ_STATUS_OK;
  flagRecover    = 0;
  clearDiag();

  init();                                                                   // initialize stuff for lm32
  initSharedMem();                                                          // initialize shared memory
  
  while (1) {
    cmdHandler(&reqState);                                                  // check for commands and possibly request state changes
    status = WRUNIPZ_STATUS_OK;                                             // reset status for each iteration
    status = changeState(&actState, &reqState, status);                     // handle requested state changes
    switch(actState)                                                        // state specific do actions
      {
      case WRUNIPZ_STATE_S0 :
        status = doActionS0();                                              // important initialization that must succeed!
        if (status != WRUNIPZ_STATUS_OK) reqState = WRUNIPZ_STATE_FATAL;    // failed:  -> FATAL
        else                             reqState = WRUNIPZ_STATE_IDLE;     // success: -> IDLE
        break;
      case WRUNIPZ_STATE_OPREADY :
        flagRecover = 0;
        status = doActionOperation(&nCycleAct, &tActCycle, status);
        if (status == WRUNIPZ_STATUS_WRBADSYNC)      reqState = WRUNIPZ_STATE_ERROR;
        if (status == WRUNIPZ_STATUS_ERROR)          reqState = WRUNIPZ_STATE_ERROR;
        break;
      case WRUNIPZ_STATE_ERROR :
        flagRecover = 1;                                                    // start autorecovery
        break; 
      case WRUNIPZ_STATE_FATAL :
        *pSharedState     = actState;
        *pSharedSumStatus = sumStatus;
        mprintf("wr-unipz: a FATAL error has occured. Good bye.\n");
        while (1) asm("nop"); // RIP!
        break;
      default :                                                             // avoid flooding WB bus with unnecessary activity
        for (j = 0; j < (WRUNIPZ_DEFAULT_TIMEOUT * WRUNIPZ_MS_ASMNOP); j++) { asm("nop"); }
      } // switch

    // autorecovery from state ERROR
    if (flagRecover) doAutoRecovery(actState, &reqState);

    // update shared memory
    if (nCycleAct != nCyclePrev) {                                            // update only one per cycle 
      if ((nCycleAct % WRUNIPZ_UNILACFREQ) == 0) {                            // about only once per second
        
        // frequency of UNILAC [nHz]
        *pSharedTCycleAvg  = (uint32_t)((tActCycle - tPrevCycle)/WRUNIPZ_UNILACFREQ);
        tPrevCycle         = tActCycle;
        
        // message rate [Hz]
        *pSharedMsgFreqAvg = (uint32_t)(nMsgAct - nMsgPrev);
        nMsgPrev           = nMsgAct;

        // virt acc and pz info
        *pSharedVaccAvg    = vaccAvg;
        *pSharedPzAvg      = pzAvg;
        vaccAvg            = 0;
        pzAvg              = 0;
      } // if nCycleAct %
      
      // reset status (hackish solution); chk: consider changing status info to bits encoded into a 32bit number 
      // if ((nCycleAct % (WRUNIPZ_UNILACFREQ * 5)) == 0) status = WRUNIPZ_STATUS_OK; 
        
      nCyclePrev = nCycleAct;
    } // if nCycleAct

    switch (status) {
    case WRUNIPZ_STATUS_OK :                                                  // status OK
      sumStatus = sumStatus |  (0x1 << WRUNIPZ_STATUS_OK);                    // set OK bit
      break;
    default :                                                                 // status not OK
      if ((sumStatus >> WRUNIPZ_STATUS_OK) & 0x1) nBadStatus++;               // changing status from OK to 'not OK': increase 'bad status count'
      sumStatus = sumStatus & ~(0x1 << WRUNIPZ_STATUS_OK);                    // clear OK bit
      sumStatus = sumStatus |  (0x1 << status);                               // set status bit and remember other bits set
      break;
    } // switch status

    if ((*pSharedState     == WRUNIPZ_STATE_OPREADY) && (actState  != WRUNIPZ_STATE_OPREADY)) nBadState++;
    *pSharedSumStatus    = sumStatus;
    *pSharedState        = actState;
    *pSharedNBadStatus   = nBadStatus;
    *pSharedNBadState    = nBadState;
    *pSharedDtMax        = dtMax;
    *pSharedDtMin        = dtMin;
    *pSharedNLate        = nLate;
    *pSharedMode         = mode;
    *pSharedNCycle       = nCycleAct; 
    *pSharedNMessageHi   = (uint32_t)(nMsgAct >> 32);
    *pSharedNMessageLo   = (uint32_t)(nMsgAct & 0xffffffff);
  } // while  
} // main
